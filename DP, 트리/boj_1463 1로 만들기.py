# 2일때는 나누기2, 3일때는 나누기 3 하고
# 3보다 큰 경우 이때 점화식을 활용한 재귀함수 dp..
# 1로 만들기!!
'''
제일 좋은건 2와 3으로 이루어진 최소공배수인가? 이게 안되면 무조건 -1 해야함.
4 = -1 %3 /  %2 %2  / %2 -1
5 = -1 %2 %2  / -1 %2 -1 / -1 -1 %3
6 = %3 %2 / %3 -1
7 = -1 %3 %2 /
10 = -1 %3 %3 /
11 = -1 -1 %3 %3 /

'''

# 2**n * 3**n 으로 이루어진 정수인가. 아니라면 -1

'''
cnt = 0
while N > 1: # N != 1
    if N % 3 == 0:
        N //= 3
        cnt += 1
    if N % 2 == 0:
        N //= 2
    else:
        N -= 1
    cnt += 1
위의 코드 문제점 10 의 경우 -1 %3 %3해서 3이 최소인데 %2 -1 %2 %2 를 진행해서 4가됨
'''
N = int(input())
memo = [0] * (10**6 +1)
memo[2] = 1
memo[3] = 1

for i in range(4, N+1):
    # 3, 2로 나누어 떨어지지 않을 경우 -1을 적용함
    # 제일 위에 표시한 이유 : 나누어 떨어지지 않을 경우가 최악의 수니까.. 나누어 떨어진다면 밑의 if문으로 덮어씀.
    memo[i] = memo[i-1] + 1
    # 계속해서 최솟값을 갱신해 나가는 것
    if i % 3 == 0:
        memo[i] = min(memo[i], memo[i//3] + 1)
    # elif가 아니라 if 를 쓰는 이유
    # ex) 624  : 6의 배수일 때 2의 배수로 나누는 것과 3의배수로 나누느 것중 2의 배수가 더 값이 작을 수도 있음
    if i % 2 == 0:
        memo[i] = min(memo[i], memo[i//2] + 1)


print(memo[N])

